/**
 * Event information injected by Defender when invoking an Action
 */
export interface ActionEvent {
  /**
   * Internal identifier of the relayer function used by the relay-client
   */
  relayerARN?: string;

  /**
   * Internal identifier of the key-value store function used by the kvstore-client
   */
  kvstoreARN?: string;

  /**
   * Internal credentials generated by Defender for communicating with other services
   */
  credentials?: string;

  /**
   * Read-only key-value secrets defined in the Action secrets vault
   */
  secrets?: ActionSecretsMap;

  /**
   * Contains a Webhook request, Monitor match information, or Monitor match request
   */
  request?: ActionRequestData;
  /**
   * actionId is the unique identifier of the Action
   */
  actionId: string;
  /**
   * Name assigned to the Action
   */
  actionName: string;
  /**
   * Id of the the current Action run
   */
  actionRunId: string;
  /**
   * Previous Action run information
   */
  previousRun?: PreviousActionRunInfo;
}

export type MonitorConfirmation = number | 'safe' | 'finalized';

export interface PreviousActionRunInfo {
  trigger: 'schedule' | 'webhook' | 'monitor' | 'monitor-filter' | 'scenario' | 'manual' | 'manual-api';
  status: 'pending' | 'throttled' | 'error' | 'success';
  createdAt: string;
  actionId: string;
  message?: string;
  actionRunId: string;
}

/**
 * Key-value secrets defined in the Action secrets vault
 */
export interface ActionSecretsMap {
  [k: string]: string;
}

/**
 * Action request data injected by Defender based on the type of trigger
 */
export interface ActionRequestData {
  /**
   * Main payload of the request: can be a generic object for a webhook request, or a typed request from Monitors
   */
  body?: MonitorConditionRequest | MonitorTriggerEvent | Record<string, unknown>;

  /**
   * Query parameters of the webhook request
   */
  queryParameters?: { [name: string]: string };

  /**
   * HTTP headers parameters of the webhook request (only headers starting with 'X-' are received)
   */
  headers?: { [name: string]: string };
}

/**
 * Payload injected by a Monitor when using an Action as a condition.
 *
 * Note that the Action should return a MonitorConditionResponse corresponding to the matched txs.
 */
export interface MonitorConditionRequest {
  /**
   * All potential matches to be evaluated by the action
   */
  events: MonitorTriggerEvent[];
}

/**
 * To be returned by an Action when invoked as a Monitor condition via a MonitorConditionRequest to refine a match
 */
export interface MonitorConditionResponse {
  /**
   * List of matches to be triggered by the Monitor, must be included in the MonitorConditionRequest
   */
  matches: MonitorConditionMatch[];
}

/**
 * Match to be triggered by the Monitor
 */
export interface MonitorConditionMatch {
  /**
   * Hash of the transaction to match
   */
  hash: string;

  /**
   * Optional user-defined metadata to include with the Monitor notification
   */
  metadata?: { [k: string]: unknown };
}

/**
 * Represents an object matched by a monitor
 */
export type MonitorTriggerEvent = BlockTriggerEvent | FortaTriggerEvent;

export interface BlockTriggerEvent {
  type: 'BLOCK';
  hash: string;
  timestamp: number;
  blockNumber: string;
  blockHash: string;
  transaction: EthReceipt;
  matchReasons: MonitorConditionSummary[];
  matchedAddresses: string[];
  matchedChecksumAddresses: string[];
  monitor: BlockMonitorSummary;
  metadata?: { [k: string]: unknown };
}

export interface FortaTriggerEvent {
  type: 'FORTA';
  hash: string;
  alert: FortaAlert;
  matchReasons: FortaConditionSummary[];
  monitor: FortaMonitorSummary;
  metadata?: { [k: string]: unknown };
}

/**
 * Summary of a Monitor definition
 */
export type MonitorSubscriberSummary = FortaMonitorSummary | BlockMonitorSummary;

export interface BlockMonitorSummary {
  id: string;
  name: string;
  network: string;
  addresses: string[];
  confirmBlocks: MonitorConfirmation;
  abi: Record<string, unknown> | undefined;
  chainId: number;
}

export interface FortaMonitorSummary {
  id: string;
  name: string;
  addresses: string[];
  // Forta have changed the terminology for 'Agent' to 'Detection Bot'
  // We will continue to refer to them as 'Agent' for now.
  // agents should be a list of Bot IDs
  agents: string[];
  network?: string;
  chainId?: number;
}

export interface MonitorBaseConditionSummary {
  condition?: string;
}

export interface MonitorBaseAbiConditionSummary extends MonitorBaseConditionSummary {
  signature: string;
  args: any[];
  address: string;
  params: { [key: string]: any };
}

export interface EventConditionSummary extends MonitorBaseConditionSummary {
  type: 'event';
}

export interface FunctionConditionSummary extends MonitorBaseConditionSummary {
  type: 'function';
}

export interface InternalFunctionConditionSummary extends MonitorBaseConditionSummary {
  type: 'internal-function';
}

export interface TransactionConditionSummary extends MonitorBaseConditionSummary {
  type: 'transaction';
}

export interface AlertIdConditionSummary {
  type: 'alert-id';
  value: string;
}

export interface SeverityConditionSummary {
  type: 'severity';
  value: string;
}

/**
 * Summary of a user-defined Monitor condition
 */
export type MonitorConditionSummary =
  | TransactionConditionSummary
  | InternalFunctionConditionSummary
  | FunctionConditionSummary
  | EventConditionSummary;

export type FortaConditionSummary = AlertIdConditionSummary | SeverityConditionSummary;

/**
 * Ethereum transaction receipt
 */
export interface EthReceipt {
  transactionHash: string;
  transactionIndex: string;
  contractAddress: string | null;
  blockHash: string;
  blockNumber: string;
  from: string;
  to: string;
  cumulativeGasUsed: string;
  gasUsed: string;
  logs: EthLog[];
  logsBloom: string;
  status: string;
}

/**
 * Ethereum transaction event log
 */
export interface EthLog {
  address?: string;
  blockHash: string;
  blockNumber: string;
  data: string;
  logIndex: string;
  removed: boolean;
  topics: string[];
  transactionHash: string;
  transactionIndex: string;
}

/**
 * Forta Alert
 */
export type FortaAlert = TxAlert | BlockAlert;

export type TxAlert = TFortaAlert & {
  addresses: string[];
  source: Source & {
    tx_hash: string;
  };
  alertType: 'TX';
};

export type BlockAlert = TFortaAlert & {
  alertType: 'BLOCK';
};

interface TFortaAlert {
  addresses?: string[];
  createdAt: string;
  severity: string;
  alertId: string;
  scanNodeCount: number;
  name: string;
  description: string;
  hash: string;
  protocol: string;
  findingType: string;
  source: Source;
  metadata: {
    [k: string]: unknown;
  };
  alertType?: 'TX' | 'BLOCK';
}

interface Source {
  transactionHash?: string;
  // deprecated, keeping for backwards compatibility
  agent: {
    id: string;
  };
  bot: {
    id: string;
  };
  block: {
    chainId: number;
    hash: string;
  };
}

export function isTxAlert(alert: FortaAlert): alert is TxAlert {
  return (alert as TxAlert).alertType === 'TX';
}

export function isBlockAlert(alert: FortaAlert): alert is BlockAlert {
  return (alert as BlockAlert).alertType === 'BLOCK';
}

export enum AlertType {
  TX = 'TX',
  BLOCK = 'BLOCK',
}

export enum SubscriberType {
  BLOCK = 'BLOCK',
  FORTA = 'FORTA',
}
